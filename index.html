<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>蝴蝶旅程</title>
  <style>
    /* 預設樣式重設與背景色 */
    body {
      margin: 0;
      padding: 0;
      background-color: transparent;//background-color: #234c2f;
      color: white;
      //text-align: center;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.8);
      touch-action: none;
    }

    /* 遊戲畫布 */
    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: transparent;
    }

    /* 虛擬搖桿區 */
    #joystick-container {
      position: absolute;
      width: 100px;
      height: 100px;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      touch-action: none;
      z-index: 20;
      display: none; /* 一開始不顯示 */
      align-items: center;
      justify-content: center;
      border: 2px solid #aaa;
      pointer-events: none; /* 重要！避免攔截滑動 */
    }

    #joystick {
      width: 40px;
      height: 40px;
      background-color: rgba(0, 255, 0, 0.5);
      border-radius: 50%;
      position: relative;
    }

    /* UI 區域 */
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
    }

    /* 能量條與生命條樣式 */
    .bar-wrapper {
      margin-bottom: 10px;
    }

    .bar {
      width: 200px;
      height: 20px;
      background-color: #555;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 2px;
    }

    .fill {
      height: 100%;
      width: 100%;
      transition: width 0.2s linear;
      border-radius: 10px;
    }

    .energy-bar .fill {
      background-color: #33cfff;
    }

    .health-bar .fill {
      background-color: #ff4e4e;
    }

  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" width="800" height="600"></canvas>
    <div id="joystick-container">
      <div id="joystick"></div>
    </div>
    <div id="ui">
      <div class="bar-wrapper">
        <label>能量</label>
        <div class="bar energy-bar"><div class="fill" id="energy-fill"></div></div>
      </div>
      <div class="bar-wrapper">
        <label>生命</label>
        <div class="bar health-bar"><div class="fill" id="health-fill"></div></div>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");
    const caterpillarImg = new Image();
    caterpillarImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/caterpillar.png'; // 確保你的圖片放在正確的資料夾中


    const energyBar = document.getElementById("energy-fill");
    const healthBar = document.getElementById("health-fill");

    const game = {
      width: canvas.width,
      height: canvas.height,
      running: true,
    };

    // === 主角毛毛蟲 ===
    const caterpillar = {
      x: game.width / 2,
      y: game.height / 2,
      radius: 30,
      speed: 2,
      energy: 100,
      health: 3,
      vx: 0,
      vy: 0,
      facingAngle: Math.PI / 2,
    };

    // === 鍵盤控制 ===
    const keys = {};
    document.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
    });
    document.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    function update() {
      // 若鍵盤控制，則優先採用
      let usingKeyboard = keys["w"] || keys["s"] || keys["a"] || keys["d"];

      // 重新設為 0
      caterpillar.vx = 0;
      caterpillar.vy = 0;

      // 按著才移動
      if (keys["w"]) caterpillar.vy -= 1;
      if (keys["s"]) caterpillar.vy += 1;
      if (keys["a"]) caterpillar.vx -= 1;
      if (keys["d"]) caterpillar.vx += 1;

      // 計算合併方向後的移動向量長度
      let len = Math.hypot(caterpillar.vx, caterpillar.vy);
      if (len > 0) {
        caterpillar.vx = (caterpillar.vx / len) * caterpillar.speed;
        caterpillar.vy = (caterpillar.vy / len) * caterpillar.speed;

        // 更新面朝角度（與虛擬搖桿一致）
        caterpillar.facingAngle = Math.atan2(caterpillar.vy, caterpillar.vx);
      }

      // 根據 vx/vy 移動（不論來源是鍵盤或搖桿）
      caterpillar.x += caterpillar.vx;
      caterpillar.y += caterpillar.vy;

      // 邊界限制
      caterpillar.x = Math.max(caterpillar.radius, Math.min(game.width - caterpillar.radius, caterpillar.x));
      caterpillar.y = Math.max(caterpillar.radius, Math.min(game.height - caterpillar.radius, caterpillar.y));
    }


    function draw() {
      // 清除畫面
      ctx.clearRect(0, 0, game.width, game.height);

      // === 畫毛毛蟲 ===
      if (caterpillarImg.complete) {
        const size = caterpillar.radius * 2;

        // 計算角度（使用 vx 和 vy 計算移動方向）
        const angle = Math.atan2(caterpillar.vy, caterpillar.vx); // (x, y) x 軸正向的夾角

        // 有移動才更新角度
        if (caterpillar.vx !== 0 || caterpillar.vy !== 0) {
          caterpillar.facingAngle = angle;
        }

        ctx.save();
        ctx.translate(caterpillar.x, caterpillar.y);
        ctx.rotate((caterpillar.facingAngle || 0) + Math.PI / 2);
        ctx.drawImage(
          caterpillarImg,
          -caterpillar.radius,
          -caterpillar.radius,
          size,
          size
        );
        ctx.restore();
      } else {
        // 圖片未載入時用圓形
        ctx.beginPath();
        ctx.arc(caterpillar.x, caterpillar.y, caterpillar.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff00";
        ctx.fill();
      }
    }

    function drawUI() {
      // 更新能量條與血條
      energyBar.style.width = `${caterpillar.energy}%`;
      healthBar.style.width = `${(caterpillar.health / 3) * 100}%`;
    }

    function gameOver() {
      game.running = false;
      ctx.fillStyle = "white";
      ctx.font = "36px sans-serif";
      ctx.fillText("遊戲結束", game.width / 2 - 80, game.height / 2);
    }

    function gameLoop() {
      if (!game.running) return;
      update();
      draw();
      drawUI();
      requestAnimationFrame(gameLoop);
    }

    // === 能量每秒自動減少 ===
    setInterval(() => {
      if (!game.running) return;
      caterpillar.energy -= 1;
      if (caterpillar.energy <= 0) {
        caterpillar.energy = 0;
        gameOver();
      }
    }, 1000);

    // === 虛擬搖桿控制 ===
    const joystickContainer = document.getElementById("joystick-container");
    const joystick = document.getElementById("joystick");
    let dragging = false;
    let joyStart = { x: 0, y: 0 };

    // 顯示搖桿並設定初始位置
    function showJoystick(x, y) {
      joystickContainer.style.display = "flex";
      joystickContainer.style.left = `${x - 50}px`; // 中心對齊
      joystickContainer.style.top = `${y - 50}px`;
      joyStart = { x, y };
    }

    // 隱藏搖桿
    function hideJoystick() {
      joystickContainer.style.display = "none";
      caterpillar.vx = 0;
      caterpillar.vy = 0;
    }

    window.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      showJoystick(touch.clientX, touch.clientY);
      dragging = true;
    });

    window.addEventListener("touchmove", (e) => {
      if (!dragging) return;
      const touch = e.touches[0];
      const dx = touch.clientX - joyStart.x;
      const dy = touch.clientY - joyStart.y;
      const len = Math.sqrt(dx * dx + dy * dy);

      if (len > 0) {
        const normX = dx / len;
        const normY = dy / len;
        caterpillar.vx = normX * caterpillar.speed;
        caterpillar.vy = normY * caterpillar.speed;
      }
    });

    window.addEventListener("touchend", () => {
      dragging = false;
      hideJoystick();
    });

    // 啟動遊戲
    gameLoop();

  </script>
</body>
</html>
