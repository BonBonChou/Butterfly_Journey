<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>遊戲頁</title>
  <style>
    /* 預設樣式重設與背景色 */
    body {
      margin: 0;
      padding: 0;
      background-color: transparent;//background-color: #234c2f;
      color: white;
      //text-align: center;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: transparent;//rgba(0, 0, 0, 0.8);
      touch-action: none;
    }

    /* 遊戲畫布 */
    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
      //background-color: transparent;
    }

    /* 虛擬搖桿區 */
    #joystick-container {
      position: absolute;
      width: 100px;
      height: 100px;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      touch-action: none;
      z-index: 20;
      display: none; /* 一開始不顯示 */
      align-items: center;
      justify-content: center;
      border: 2px solid #aaa;
      pointer-events: none; /* 重要！避免攔截滑動 */
    }

    #joystick {
      width: 40px;
      height: 40px;
      background-color: rgba(0, 255, 0, 0.5);
      border-radius: 50%;
      position: relative;
    }

    /* UI 區域 */
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
    }

    /* 能量條與生命條樣式 */
    .bar-wrapper {
      margin-bottom: 10px;
    }

    .bar {
      width: 200px;
      height: 20px;
      background-color: #555;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 2px;
    }

    .fill {
      height: 100%;
      width: 100%;
      transition: width 0.2s linear;
      border-radius: 10px;
    }

    .energy-bar .fill {
      background-color: #33cfff;
    }

    .health-bar .fill {
      background-color: #ff4e4e;
    }

  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" width="800" height="600"></canvas>
    <div id="joystick-container">
      <div id="joystick"></div>
    </div>
    <div id="ui">
      <div class="bar-wrapper">
        <label>能量</label>
        <div class="bar energy-bar"><div class="fill" id="energy-fill"></div></div>
      </div>
      <div class="bar-wrapper">
        <label>生命</label>
        <div class="bar health-bar"><div class="fill" id="health-fill"></div></div>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");
    const caterpillarImg = new Image();
    caterpillarImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/caterpillar.png';
    const grassImg = new Image();
    grassImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/bg.png'; // 你的草地圖

    const energyBar = document.getElementById("energy-fill");
    const healthBar = document.getElementById("health-fill");
    let isUsingJoystick = false;

    const game = {
      width: canvas.width,
      height: canvas.height,
      running: true,
    };

    // === 主角毛毛蟲 ===
    const caterpillar = {
      worldX: 0, // 以世界為基準的座標
      worldY: 0,
      radius: 30,
      speed: 2,
      energy: 100,
      health: 3,
      vx: 0,
      vy: 0,
      facingAngle: Math.PI / 2,
    };
    const camera = { // 相機偏移計算
      x: 0,
      y: 0
    };

    // ======================== 鍵盤控制 =================================================================
    const keys = {};
    document.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      isUsingJoystick = false;
    });
    document.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    function update() {
      if (!isUsingJoystick) {
        // 鍵盤控制時，重設速度
        caterpillar.vx = 0;
        caterpillar.vy = 0;

        if (keys["w"]) caterpillar.vy -= 1;
        if (keys["s"]) caterpillar.vy += 1;
        if (keys["a"]) caterpillar.vx -= 1;
        if (keys["d"]) caterpillar.vx += 1;

        // 用畫布的比例來修正
        const scaleY = canvas.width / canvas.height;
        let len = Math.hypot(caterpillar.vx, caterpillar.vy * scaleY);
        if (len > 0) {
          caterpillar.vx = (caterpillar.vx / len) * caterpillar.speed;
          caterpillar.vy = (caterpillar.vy / len) * caterpillar.speed;
          caterpillar.facingAngle = Math.atan2(caterpillar.vy, caterpillar.vx);
        }
      }

      // 位置更新（無論是哪個控制方式）
      caterpillar.worldX += caterpillar.vx;
      caterpillar.worldY += caterpillar.vy;

      // 讓相機中心對準角色
      camera.x = caterpillar.worldX - game.width / 2;
      camera.y = caterpillar.worldY - game.height / 2;
    }



    function draw() {
      // 清除畫面
      ctx.clearRect(0, 0, game.width, game.height);
      drawBackground();

      // === 畫毛毛蟲 ===
      if (caterpillarImg.complete) {
        const size = caterpillar.radius * 2;

        // 計算角度（使用 vx 和 vy 計算移動方向）
        const angle = Math.atan2(caterpillar.vy, caterpillar.vx); // (x, y) x 軸正向的夾角

        // 有移動才更新角度
        if (caterpillar.vx !== 0 || caterpillar.vy !== 0) {
          caterpillar.facingAngle = angle;
        }

        ctx.save();
        ctx.translate(game.width / 2, game.height / 2); // 固定畫在螢幕中心
        ctx.rotate((caterpillar.facingAngle || 0) + Math.PI / 2);
        // 設定陰影來模擬外框
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 5; // 模糊值，越小描邊越銳利；越大越柔和。
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // 畫毛毛蟲圖片（陰影會圍繞透明部分）
        ctx.drawImage(
          caterpillarImg,
          -caterpillar.radius,
          -caterpillar.radius,
          size,
          size
        );
        ctx.restore();
      } else {
        // 圖片未載入時用圓形
        ctx.beginPath();
        ctx.arc(caterpillar.x, caterpillar.y, caterpillar.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff00";
        ctx.fill();
      }
    }

    function drawBackground() {
      const pattern = ctx.createPattern(grassImg, 'repeat');
      ctx.save();
      ctx.globalAlpha = 0.95; // 透明度（0=完全透明，1=不透明）
      ctx.translate(-camera.x % grassImg.width, -camera.y % grassImg.height);
      ctx.fillStyle = pattern;
      ctx.fillRect(-grassImg.width, -grassImg.height, game.width + grassImg.width * 2, game.height + grassImg.height * 2);
      ctx.restore();
    }


    function drawUI() {
      // 更新能量條與血條
      energyBar.style.width = `${caterpillar.energy}%`;
      healthBar.style.width = `${(caterpillar.health / 3) * 100}%`;
    }

    function gameOver() {
      game.running = false;
      location.href="https://bonbonchou.github.io/Butterfly_Journey/fail_ending.html";
    }

    function gameLoop() {
      if (!game.running) return;
      update();
      draw();
      drawUI();
      requestAnimationFrame(gameLoop);
    }

    // === 能量每秒自動減少 ===
    setInterval(() => {
      if (!game.running) return;
      caterpillar.energy -= 1;
      if (caterpillar.energy <= 0) {
        caterpillar.energy = 0;
        gameOver();
      }
    }, 1000);

    // =================================== 虛擬搖桿控制 ==================================================================
    const joystickContainer = document.getElementById("joystick-container");
    const joystick = document.getElementById("joystick");
    let dragging = false;
    let joyStart = { x: 0, y: 0 };

    // 顯示搖桿並設定初始位置
    function showJoystick(x, y) {
      joystickContainer.style.display = "flex";
      joystickContainer.style.left = `${x - 50}px`; // 中心對齊
      joystickContainer.style.top = `${y - 50}px`;
      joyStart = { x, y };
    }

    // 隱藏搖桿
    function hideJoystick() {
      joystickContainer.style.display = "none";
      caterpillar.vx = 0;
      caterpillar.vy = 0;
    }

    window.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      showJoystick(touch.clientX, touch.clientY);
      dragging = true;
      isUsingJoystick = true; // 代表當前由搖桿控制
    });

    window.addEventListener("touchmove", (e) => {
      if (!dragging) return;
      const touch = e.touches[0];
      
      const rect = canvas.getBoundingClientRect();

      // 轉換成 canvas 內的相對距離（0 ~ 實際繪圖單位）
      const dx = (touch.clientX - joyStart.x) * (canvas.width / rect.width);
      const dy = (touch.clientY - joyStart.y) * (canvas.height / rect.height);
      
      const scaleY = canvas.width / canvas.height; // 用比例修正
      const len = Math.hypot(dx, dy * scaleY);

      if (len > 0) {
        const normX = dx / len;
        const normY = dy / len;
        caterpillar.vx = normX * caterpillar.speed;
        caterpillar.vy = normY * caterpillar.speed;
      }
    });

    window.addEventListener("touchend", () => {
      dragging = false;
      hideJoystick();
      isUsingJoystick = false; // 停止使用搖桿控制
    });

    // 啟動遊戲
    gameLoop();

  </script>
</body>
</html>
