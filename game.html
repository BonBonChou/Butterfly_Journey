<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>遊戲頁</title>
  <style>
    /* 預設樣式重設與背景色 */
    body {
      margin: 0;
      padding: 0;
      background-color: transparent;//background-color: #234c2f;
      color: white;
      //text-align: center;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: transparent;//rgba(0, 0, 0, 0.8);
      touch-action: none;
    }

    /* 遊戲畫布 */
    canvas {
      position: absolute;     /* 把兩張 canvas 疊在容器裡 */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    #game-canvas { z-index: 0; }
    #mask-canvas { z-index: 10; pointer-events: none; }
    #ui-canvas   { z-index: 20; pointer-events: none; }

    /* 虛擬搖桿區 */
    #joystick-container {
      position: absolute;
      width: 100px;
      height: 100px;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      touch-action: none;
      z-index: 20;
      display: none; /* 一開始不顯示 */
      align-items: center;
      justify-content: center;
      border: 2px solid #aaa;
      pointer-events: none; /* 重要！避免攔截滑動 */
    }

    #joystick {
      width: 40px;
      height: 40px;
      background-color: rgba(0, 255, 0, 0.5);
      border-radius: 50%;
      position: relative;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" width="800" height="600"></canvas>
    <canvas id="mask-canvas" width="800" height="600"></canvas> <!-- 上層畫黑色遮罩 -->
    <canvas id="ui-canvas" width="800" height="600"></canvas>   <!-- UI & 毛毛蟲 -->
    <div id="joystick-container">
      <div id="joystick"></div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");
    const maskCanvas = document.getElementById("mask-canvas");
    const maskCtx = maskCanvas.getContext("2d");
    const uiCanvas = document.getElementById("ui-canvas");
    const uiCtx = uiCanvas.getContext("2d");
    let isButterfly = false;  // 預設是毛毛蟲狀態，有視野限制

    const caterpillarImg = new Image();
    caterpillarImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/caterpillar.png';
    const grassImg = new Image();
    grassImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/bg.png'; // 你的草地圖

    const energyBar = document.getElementById("energy-fill");
    const healthBar = document.getElementById("health-fill");
    let isUsingJoystick = false;

    const game = {
      width: canvas.width,
      height: canvas.height,
      running: true,
    };

    // ============= 主角毛毛蟲 ===============================
    const caterpillar = {
      worldX: 0, // 以世界為基準的座標
      worldY: 0,
      radius: 30,
      speed: 2,
      energy: 100,
      health: 100,     // 當前血量
      maxHealth: 100,  // 血量上限
      vx: 0,
      vy: 0,
      facingAngle: Math.PI / 2,
      level: 1,
      exp: 0,
      expToNext: 30,
    };
    function drawPlayer() { // === 畫毛毛蟲 ===
      uiCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height); // 每次清掉舊的遮罩
      if (caterpillarImg.complete) {
        const size = caterpillar.radius * 2;

        // 計算角度（使用 vx 和 vy 計算移動方向）
        const angle = Math.atan2(caterpillar.vy, caterpillar.vx); // (x, y) x 軸正向的夾角

        // 有移動才更新角度
        if (caterpillar.vx !== 0 || caterpillar.vy !== 0) {
          caterpillar.facingAngle = angle;
        }

        uiCtx.save();
        uiCtx.translate(game.width / 2, game.height / 2); // 固定畫在螢幕中心
        uiCtx.rotate((caterpillar.facingAngle || 0) + Math.PI / 2);
        // 設定陰影來模擬外框
        uiCtx.shadowColor = 'black';
        uiCtx.shadowBlur = 20; // 模糊值，越小描邊越銳利；越大越柔和。
        uiCtx.shadowOffsetX = 0;
        uiCtx.shadowOffsetY = 0;

        // 畫毛毛蟲圖片（陰影會圍繞透明部分）
        uiCtx.drawImage(
          caterpillarImg,
          -caterpillar.radius,
          -caterpillar.radius,
          size,
          size
        );
        uiCtx.restore();
      } else {
        // 圖片未載入時用圓形
        uiCtx.beginPath();
        uiCtx.arc(caterpillar.x, caterpillar.y, caterpillar.radius, 0, Math.PI * 2);
        uiCtx.fillStyle = "#00ff00";
        uiCtx.fill();
      }
    }

    const camera = { // 相機偏移計算
      x: 0,
      y: 0
    };

    // 毛毛蟲視野設定
    const caterpillarVision = {
      angle: Math.PI / 3, // 60 度視野
      range: 200 // 視野距離
      //caterpillarVision.range *= 1.5;  // 視野距離增加 50%
      //caterpillarVision.angle *= 1.2;  // 視野角度增加 20%
    };

    // 畫黑色遮罩並挖出視野
    function drawVisionMask() {
      if (isButterfly) return;  // 是蝴蝶就不畫遮罩
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height); // 每次清掉舊的遮罩

      // Step 1: 黑色遮罩
      maskCtx.fillStyle = "rgba(0, 0, 0, 0.95)";
      maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

      // Step 2: 挖出視野
      maskCtx.globalCompositeOperation = "destination-out";
      maskCtx.beginPath();
      maskCtx.moveTo(game.width / 2, game.height / 2);
      maskCtx.arc(
        game.width / 2,
        game.height / 2,
        caterpillarVision.range,
        caterpillar.facingAngle - caterpillarVision.angle / 2,
        caterpillar.facingAngle + caterpillarVision.angle / 2
      );
      maskCtx.closePath();
      maskCtx.fill();

      maskCtx.globalCompositeOperation = "source-over"; // 還原混合模式
    }


    // ======================== 鍵盤控制 =================================================================
    const keys = {};
    document.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      isUsingJoystick = false;
    });
    document.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    // ---------------------乳草-------------------------------------
    const milkweeds = [];
    const milkweedImg = new Image();
    milkweedImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/milkweed.png';
    function spawnMilkweed() {
      const spawnX = caterpillar.worldX + (Math.random() - 0.5) * 800;
      const spawnY = caterpillar.worldY + (Math.random() - 0.5) * 800;

      milkweeds.push({
        x: spawnX,
        y: spawnY,
        spawnTime: Date.now(),
        lifespan: 10000 // 10 秒後消失
      });
    }
    function updateMilkweeds() {
      const now = Date.now();
      for (let i = milkweeds.length - 1; i >= 0; i--) {
        if (now - milkweeds[i].spawnTime > milkweeds[i].lifespan) {
          milkweeds.splice(i, 1); // 移除過期乳草
        }
      }
    }
    function drawMilkweeds() {
      milkweeds.forEach(m => {
        const screenX = m.x - camera.x;
        const screenY = m.y - camera.y;
        ctx.save();

        // 設定陰影來模擬外框
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 20; // 模糊值
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // 繪製乳草
        ctx.drawImage(milkweedImg, screenX - 20, screenY - 20, 40, 40);

        ctx.restore();
      });
    }
    // ------------------------EXP系統、生命、能量----------------------------------------
    function gainExp(amount) {
      caterpillar.exp += amount;
      if (caterpillar.exp >= caterpillar.expToNext) {
        caterpillar.exp -= caterpillar.expToNext;
        caterpillar.level++;
        caterpillar.expToNext = Math.floor(caterpillar.expToNext * 1.2);
        triggerLevelUpEvent();
      }
    }

    function triggerLevelUpEvent() {
      // console.log(`等級提升至 ${caterpillar.level}！觸發事件！`);
      // TODO: 之後你可以在這裡加上升級特效或事件
    }

    function drawPlayerBars() {
      const barWidth = 60;
      const barHeight = 6;
      const screenX = game.width / 2;
      const screenY = game.height / 2 + caterpillar.radius + 8;

      // 生命條（紅色）
      uiCtx.fillStyle = "#555";
      uiCtx.fillRect(screenX - barWidth / 2, screenY, barWidth, barHeight);
      uiCtx.fillStyle = "#ff4e4e";
      uiCtx.fillRect(screenX - barWidth / 2, screenY, barWidth * (caterpillar.health / caterpillar.maxHealth), barHeight);

      // 能量條（藍色）
      const energyY = screenY + barHeight + 4;
      uiCtx.fillStyle = "#555";
      uiCtx.fillRect(screenX - barWidth / 2, energyY, barWidth, barHeight);
      uiCtx.fillStyle = "#33cfff";
      uiCtx.fillRect(screenX - barWidth / 2, energyY, barWidth * (caterpillar.energy / 100), barHeight);
    }

    function drawExpBar() {
      const barWidth = 700;
      const barHeight = 25;
      const marginTop = 10;

      uiCtx.fillStyle = "#222";
      uiCtx.fillRect((game.width - barWidth) / 2, marginTop, barWidth, barHeight);
      uiCtx.fillStyle = "#88ff88";
      uiCtx.fillRect((game.width - barWidth) / 2, marginTop, barWidth * (caterpillar.exp / caterpillar.expToNext), barHeight);

      // 畫等級文字
      uiCtx.fillStyle = "white";
      uiCtx.font = "bold 30px Times New Roman";
      uiCtx.textAlign = "center";
      uiCtx.fillText(`LV. ${caterpillar.level}`, game.width / 2, marginTop + barHeight - 2);
    }

    //--------------更新畫面-----------------------------------
    function update() {
      if (!isUsingJoystick) {
        // 鍵盤控制時，重設速度
        caterpillar.vx = 0;
        caterpillar.vy = 0;

        if (keys["w"]) caterpillar.vy -= 1;
        if (keys["s"]) caterpillar.vy += 1;
        if (keys["a"]) caterpillar.vx -= 1;
        if (keys["d"]) caterpillar.vx += 1;

        // 用畫布的比例來修正
        const scaleY = canvas.width / canvas.height;
        let len = Math.hypot(caterpillar.vx, caterpillar.vy * scaleY);
        if (len > 0) {
          caterpillar.vx = (caterpillar.vx / len) * caterpillar.speed;
          caterpillar.vy = (caterpillar.vy / len) * caterpillar.speed;
          caterpillar.facingAngle = Math.atan2(caterpillar.vy, caterpillar.vx);
        }
      }
      updateMilkweeds();

      // 位置更新（無論是哪個控制方式）
      caterpillar.worldX += caterpillar.vx;
      caterpillar.worldY += caterpillar.vy;

      // 讓相機中心對準角色
      camera.x = caterpillar.worldX - game.width / 2;
      camera.y = caterpillar.worldY - game.height / 2;

      // === 檢查毛毛蟲與乳草碰撞 ===
      for (let i = milkweeds.length - 1; i >= 0; i--) {
        const dx = caterpillar.worldX - milkweeds[i].x;
        const dy = caterpillar.worldY - milkweeds[i].y;
        const dist = Math.hypot(dx, dy);

        if (dist < caterpillar.radius + 20) { // 20 是乳草半徑
          // 能量回復（上限 100）
          caterpillar.energy = Math.min(100, caterpillar.energy + 10);

          // 經驗值增加（用你現有的系統）
          gainExp(5); // 每顆乳草給 5 點經驗

          // 移除乳草
          milkweeds.splice(i, 1);
        }
      }
    }

    function draw() {
      // 清除畫面
      ctx.clearRect(0, 0, game.width, game.height);
      drawBackground();
      drawMilkweeds();
      // 先畫地圖與物件，再畫黑色遮罩
      drawVisionMask();
      // 再畫毛毛蟲、經驗條，確保它永遠可見
      drawPlayer();
      drawPlayerBars();
      drawExpBar();
    }

    function drawBackground() {
      const pattern = ctx.createPattern(grassImg, 'repeat');
      ctx.save();
      ctx.globalAlpha = 0.8; // 透明度（0=完全透明，1=不透明）
      ctx.translate(-camera.x % grassImg.width, -camera.y % grassImg.height);
      ctx.fillStyle = pattern;
      ctx.fillRect(-grassImg.width, -grassImg.height, game.width + grassImg.width * 2, game.height + grassImg.height * 2);
      ctx.restore();
    }

    function gameOver() {
      game.running = false;
      location.href="https://bonbonchou.github.io/Butterfly_Journey/fail_ending.html";
    }

    function gameLoop() {
      if (!game.running) return;
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // === 能量每秒自動減少 ===
    setInterval(() => {
      if (!game.running) return;
      caterpillar.energy -= 1;
      if (caterpillar.energy <= 0) {
        caterpillar.energy = 0;
        gameOver();
      }
    }, 1000);

    // =================================== 虛擬搖桿控制 ==================================================================
    const joystickContainer = document.getElementById("joystick-container");
    const joystick = document.getElementById("joystick");
    let dragging = false;
    let joyStart = { x: 0, y: 0 };

    // 顯示搖桿並設定初始位置
    function showJoystick(x, y) {
      joystickContainer.style.display = "flex";
      joystickContainer.style.left = `${x - 50}px`; // 中心對齊
      joystickContainer.style.top = `${y - 50}px`;
    }

    // 隱藏搖桿
    function hideJoystick() {
      joystickContainer.style.display = "none";
      caterpillar.vx = 0;
      caterpillar.vy = 0;
    }

    // 將螢幕座標轉換為 Canvas 內部座標
    function getCanvasCoordinates(touchEvent) {
        const rect = canvas.getBoundingClientRect(); // 獲取畫布在螢幕上的實際位置和大小
        const touch = touchEvent.touches[0];

        // 計算縮放比例
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // 進行座標轉換
        const canvasX = (touch.clientX - rect.left) * scaleX;
        const canvasY = (touch.clientY - rect.top) * scaleY;

        return { x: canvasX, y: canvasY };
    }

    window.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      // 視覺上的搖桿依然使用螢幕座標，才能正確顯示在手指下方
      showJoystick(touch.clientX, touch.clientY); 
      
      // 但我們的遊戲邏輯，使用轉換後的畫布座標
      const coords = getCanvasCoordinates(e);
      joyStart = { x: coords.x, y: coords.y };
      dragging = true;
      isUsingJoystick = true; // 代表當前由搖桿控制
    });

    window.addEventListener("touchmove", (e) => {
      if (!dragging) return;
      // 同樣，將當前手指位置也轉換為畫布座標
      const coords = getCanvasCoordinates(e);

      // dx 和 dy 現在是基於 800x600 畫布的正確向量
      const dx = coords.x - joyStart.x;
      const dy = coords.y - joyStart.y;

      const len = Math.hypot(dx, dy); // 因為座標已經被校正，不再需要手動乘以 scaleY
      if (len > 0) {
        // 直接用 dx 和 dy 來計算速度，len 會負責將其標準化
        caterpillar.vx = 1.5 * (dx / len) * caterpillar.speed;
        caterpillar.vy = 1.5 *(dy / len) * caterpillar.speed;
      }
    });

    window.addEventListener("touchend", () => {
      dragging = false;
      hideJoystick();
      isUsingJoystick = false; // 停止使用搖桿控制
    });

    // 啟動遊戲
    gameLoop();

    setInterval(() => {
      if (game.running) {
        spawnMilkweed();
      }
    }, 2000); // 每 2 秒生成一次

  </script>
</body>
</html>
