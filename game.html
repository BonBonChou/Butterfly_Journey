<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>遊戲頁</title>
  <style>
    /* 預設樣式重設與背景色 */
    body {
      margin: 0;
      padding: 0;
      background-color: transparent;//background-color: #234c2f;
      color: white;
      //text-align: center;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: transparent;//rgba(0, 0, 0, 0.8);
      touch-action: none;
    }

    /* 遊戲畫布 */
    canvas {
      position: absolute;     /* 把兩張 canvas 疊在容器裡 */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    #game-canvas { z-index: 0; }
    #mask-canvas { z-index: 10; pointer-events: none; }
    #ui-canvas   { z-index: 20; pointer-events: none; }

    /* 升級選項卡 */
    #upgrade-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      gap: 20px;
      z-index: 1000;
    }
    .upgrade-card {
      background: rgba(0,0,0,0.85);
      border: 2px solid #fff;
      border-radius: 10px;
      padding: 15px;
      width: 200px;
      color: white;
      cursor: pointer;
      text-align: center;
      transition: transform 0.15s ease;
    }
    .upgrade-card:hover {
      transform: scale(1.05);
      border-color: yellow;
    }
    .upgrade-name {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .upgrade-desc {
      font-size: 14px;
    }

    /* 虛擬搖桿區 */
    #joystick-container {
      position: absolute;
      width: 100px;
      height: 100px;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      touch-action: none;
      z-index: 20;
      display: none; /* 一開始不顯示 */
      align-items: center;
      justify-content: center;
      border: 2px solid #aaa;
      pointer-events: none; /* 重要！避免攔截滑動 */
    }

    #joystick {
      width: 40px;
      height: 40px;
      background-color: rgba(0, 255, 0, 0.5);
      border-radius: 50%;
      position: relative;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" width="800" height="600"></canvas>
    <canvas id="mask-canvas" width="800" height="600"></canvas> <!-- 上層畫黑色遮罩 -->
    <canvas id="ui-canvas" width="800" height="600"></canvas>   <!-- UI & 毛毛蟲 -->
    <!-- 升級選項容器 -->
    <div id="upgrade-container" style="display:none;">
      <div class="upgrade-card" onclick="pickUpgradeFromUI(0)">
        <div class="upgrade-name" id="upgrade-name-0"></div>
        <div class="upgrade-desc" id="upgrade-desc-0"></div>
      </div>
      <div class="upgrade-card" onclick="pickUpgradeFromUI(1)">
        <div class="upgrade-name" id="upgrade-name-1"></div>
        <div class="upgrade-desc" id="upgrade-desc-1"></div>
      </div>
      <div class="upgrade-card" onclick="pickUpgradeFromUI(2)">
        <div class="upgrade-name" id="upgrade-name-2"></div>
        <div class="upgrade-desc" id="upgrade-desc-2"></div>
      </div>
    </div>
    <!-- 虛擬搖桿 -->
    <div id="joystick-container">
      <div id="joystick"></div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");
    const maskCanvas = document.getElementById("mask-canvas");
    const maskCtx = maskCanvas.getContext("2d");
    const uiCanvas = document.getElementById("ui-canvas");
    const uiCtx = uiCanvas.getContext("2d");
    let isButterfly = false;  // 預設是毛毛蟲狀態，有視野限制

    let caterpillarImg = new Image();
    caterpillarImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/caterpillar.png';
    const grassImg = new Image();
    grassImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/bg.png';

    const butterflyImg = new Image();
    butterflyImg.src = "https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/butterfly.png";

    const energyBar = document.getElementById("energy-fill");
    const healthBar = document.getElementById("health-fill");
    let isUsingJoystick = false;

    const game = {
      width: canvas.width,
      height: canvas.height,
      running: true,
    };

    // ============= 主角毛毛蟲 ===============================
    const caterpillar = {
      worldX: 0, // 以世界為基準的座標
      worldY: 0,
      radius: 30,
      speed: 2,
      energy: 100,
      health: 100,     // 當前血量
      maxHealth: 100,  // 血量上限
      vx: 0,
      vy: 0,
      facingAngle: Math.PI / 2,
      level: 1,
      exp: 0,
      expToNext: 20,
      regenRate: 0,        // 每秒回血比例（0.01 = 1%）
      hasRegen: false,
      energyGainMult: 1,   // 吃乳草得到能量的倍率（1.0 = 原量）
      nectarSpeedMult: 1,  // 吸花蜜速度的倍率（1.0 = 原量）
      // stealth 相關欄位（新增）
      hasStealth: false,      // 由升級啟用（你的 apply() 已會設 true）
      isStealthed: false,     // 當前是否處於隱形狀態
      stoppedSince: null,     // 若靜止，記錄開始靜止的時間（ms）
      stealthAlpha: 0.45      // 隱形時畫面透明度
    };
    function drawPlayer() { // === 畫毛毛蟲 ===
      uiCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height); // 每次清掉舊的遮罩
      if (caterpillarImg.complete) {
        const size = caterpillar.radius * 2;

        // 計算角度（使用 vx 和 vy 計算移動方向）
        const angle = Math.atan2(caterpillar.vy, caterpillar.vx); // (x, y) x 軸正向的夾角

        // 有移動才更新角度
        if (caterpillar.vx !== 0 || caterpillar.vy !== 0) {
          caterpillar.facingAngle = angle;
        }

        uiCtx.save();
        uiCtx.translate(game.width / 2, game.height / 2); // 固定畫在螢幕中心
        uiCtx.rotate((caterpillar.facingAngle || 0) + Math.PI / 2);

        // 設定透明度：若隱形就使用 stealthAlpha
        uiCtx.globalAlpha = caterpillar.isStealthed ? caterpillar.stealthAlpha : 1.0;

        // 設定陰影來模擬外框
        uiCtx.shadowColor = 'black';
        uiCtx.shadowBlur = 20; // 模糊值，越小描邊越銳利；越大越柔和。
        uiCtx.shadowOffsetX = 0;
        uiCtx.shadowOffsetY = 0;

        // 畫毛毛蟲圖片（陰影會圍繞透明部分）
        uiCtx.drawImage(
          caterpillarImg,
          -caterpillar.radius,
          -caterpillar.radius,
          size,
          size
        );

        // 恢復 alpha（非常重要）
        uiCtx.globalAlpha = 1.0;

        uiCtx.restore();
      } else {
        // 圖片未載入時用圓形
        uiCtx.beginPath();
        uiCtx.arc(caterpillar.x, caterpillar.y, caterpillar.radius, 0, Math.PI * 2);
        uiCtx.fillStyle = "#00ff00";
        uiCtx.fill();
      }
    }

    const camera = { // 相機偏移計算
      x: 0,
      y: 0
    };

    // 毛毛蟲視野設定
    const caterpillarVision = {
      angle: Math.PI / 3, // 60 度視野
      range: 200 // 視野距離
    };

    // 畫黑色遮罩並挖出視野
    function drawVisionMask() {
      if (isButterfly) return;  // 是蝴蝶就不畫遮罩
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height); // 每次清掉舊的遮罩

      // Step 1: 黑色遮罩
      maskCtx.fillStyle = "rgba(0, 0, 0, 0.95)";
      maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

      // Step 2: 挖出視野
      maskCtx.globalCompositeOperation = "destination-out";
      maskCtx.beginPath();
      maskCtx.moveTo(game.width / 2, game.height / 2);
      maskCtx.arc(
        game.width / 2,
        game.height / 2,
        caterpillarVision.range,
        caterpillar.facingAngle - caterpillarVision.angle / 2,
        caterpillar.facingAngle + caterpillarVision.angle / 2
      );
      maskCtx.closePath();
      maskCtx.fill();

      maskCtx.globalCompositeOperation = "source-over"; // 還原混合模式
    }


    // ======================== 鍵盤控制 =================================================================
    const keys = {};
    document.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      isUsingJoystick = false;
    });
    document.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    // ---------------------乳草-------------------------------------
    const milkweeds = [];
    const milkweedImg = new Image();
    milkweedImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/milkweed.png';
    function spawnMilkweed() {
      const spawnX = caterpillar.worldX + (Math.random() - 0.5) * 800;
      const spawnY = caterpillar.worldY + (Math.random() - 0.5) * 800;

      milkweeds.push({
        x: spawnX,
        y: spawnY,
        spawnTime: Date.now(),
        lifespan: 10000 // 10 秒後消失
      });
    }
    function updateMilkweeds() {
      const now = Date.now();
      for (let i = milkweeds.length - 1; i >= 0; i--) {
        if (now - milkweeds[i].spawnTime > milkweeds[i].lifespan) {
          milkweeds.splice(i, 1); // 移除過期乳草
        }
      }
    }
    function drawMilkweeds() {
      milkweeds.forEach(m => {
        const screenX = m.x - camera.x;
        const screenY = m.y - camera.y;
        ctx.save();

        // 設定陰影來模擬外框
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 20; // 模糊值
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // 繪製乳草
        ctx.drawImage(milkweedImg, screenX - 20, screenY - 20, 40, 40);

        ctx.restore();
      });
    }
    // -------------------- 花的資料 --------------------
    let flowers = [];
    let flowerSpawnInterval;
    const flowerImg = new Image();
    flowerImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/flower.png';

    // 吸食進度
    let feedingFlower = null;
    let feedingProgress = 0;
    let feedingTime = 3000; // 3 秒（毫秒）

    // -------------------- 生成花（羽化後才啟動） --------------------
    function spawnFlower() {
      const spawnX = caterpillar.worldX + (Math.random() - 0.5) * 800;
      const spawnY = caterpillar.worldY + (Math.random() - 0.5) * 800;

      flowers.push({
        x: spawnX,
        y: spawnY,
        spawnTime: Date.now(),
        lifespan: 10000 // 10 秒後消失
      });
    }

    // -------------------- 更新花的吸食邏輯 --------------------
    function updateFlowers() {
      const now = Date.now();
      for (let i = flowers.length - 1; i >= 0; i--) {
        if (now - flowers[i].spawnTime > flowers[i].lifespan) {
          flowers.splice(i, 1); // 移除過期花
        }
      }
    }

    // -------------------- 畫花 --------------------
    function drawFlowers() {
      flowers.forEach(f => {
        const screenX = f.x - camera.x;
        const screenY = f.y - camera.y;

        ctx.drawImage(flowerImg, screenX - 20, screenY - 20, 40, 40);

        // 如果這是正在吸食的花，畫讀條
        if (f === feedingFlower) {
          const progressRatio = feedingProgress / feedingTime;
          ctx.beginPath();
          ctx.arc(screenX, screenY - 30, 15, -Math.PI / 2, -Math.PI / 2 + progressRatio * 2 * Math.PI);
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 4;
          ctx.stroke();
        }
      });
    }

    // -------------------- 羽化後初始化花系統 --------------------
    function startFlowerMode() {
      //clearInterval(milkweedSpawnInterval); // 停止乳草生成
      flowers = [];
      feedingFlower = null;
      feedingProgress = 0;
      //flowerSpawnInterval = setInterval(spawnFlower, 3000); // 每 3 秒生成一朵
    }

    // ------------------------EXP系統、生命、能量----------------------------------------
    function gainExp(baseAmount) {
      const gain = Math.round(baseAmount * (1 + (caterpillar.expGainMult || 0)));
      caterpillar.exp += gain;
      if (caterpillar.exp >= caterpillar.expToNext) {
        caterpillar.exp -= caterpillar.expToNext;
        caterpillar.level++;
        caterpillar.expToNext = Math.floor(caterpillar.expToNext * 1.2);
        triggerLevelUpEvent();
      }
    }

    function drawPlayerBars() {
      const barWidth = 60;
      const barHeight = 6;
      const screenX = game.width / 2;
      const screenY = game.height / 2 + caterpillar.radius + 8;

      // 生命條（紅色）
      uiCtx.fillStyle = "#555";
      uiCtx.fillRect(screenX - barWidth / 2, screenY, barWidth, barHeight);
      uiCtx.fillStyle = "#ff4e4e";
      uiCtx.fillRect(screenX - barWidth / 2, screenY, barWidth * (caterpillar.health / caterpillar.maxHealth), barHeight);

      // 能量條（藍色）
      const energyY = screenY + barHeight + 4;
      uiCtx.fillStyle = "#555";
      uiCtx.fillRect(screenX - barWidth / 2, energyY, barWidth, barHeight);
      uiCtx.fillStyle = "#33cfff";
      uiCtx.fillRect(screenX - barWidth / 2, energyY, barWidth * (caterpillar.energy / 100), barHeight);
    }

    function drawExpBar() {
      const barWidth = 700;
      const barHeight = 25;
      const marginTop = 10;

      uiCtx.fillStyle = "#222";
      uiCtx.fillRect((game.width - barWidth) / 2, marginTop, barWidth, barHeight);
      uiCtx.fillStyle = "#88ff88";
      uiCtx.fillRect((game.width - barWidth) / 2, marginTop, barWidth * (caterpillar.exp / caterpillar.expToNext), barHeight);

      // 畫等級文字
      uiCtx.fillStyle = "white";
      uiCtx.font = "bold 30px Times New Roman";
      uiCtx.textAlign = "center";
      uiCtx.fillText(`LV. ${caterpillar.level}`, game.width / 2, marginTop + barHeight - 2);
    }
    //--------------升級--------------------------------------
    // 升級項目資料（desc 使用 function 以便動態顯示「選取後」的數值）
    const upgrades = [
      { 
        id: "stealth", 
        name: "擬態", 
        desc: () => "靜止 3 秒後進入隱身狀態，移動後失效。隱身時不會遭受任何傷害",
        maxPick: 1,
        apply: () => { caterpillar.hasStealth = true; }
      },
      { 
        id: "speedUp", 
        name: "移速增加 20%", 
        desc: () => "速度 +20%",
        maxPick: 3,
        apply: () => { caterpillar.speed *= 1.2; }
      },
      { 
        id: "visionRangeUp", 
        name: "視野距離增加 20%", 
        desc: () => `視野距離 +20%`,
        maxPick: 3,
        apply: () => { caterpillarVision.range *= 1.2; }
      },
      { 
        id: "visionAngleUp", 
        name: "視野角度增加 20%", 
        desc: () => `視野角度 +20%`,
        maxPick: 3,
        apply: () => { caterpillarVision.angle *= 1.2; }
      },
      { 
        id: "maxHpUp", 
        name: "血量 +20", 
        desc: () => "最大血量 +20 並回滿血",
        maxPick: Infinity,
        apply: () => { 
          caterpillar.maxHealth += 20; 
          caterpillar.health = caterpillar.maxHealth;
        }
      },
      { 
        id: "regen", 
        name: "自動回血", 
        desc: () => {
          const cur = caterpillar.regenRate || 0;
          const future = cur + 0.01; // 每次 +1%（0.01）
          return `每秒回復 ${Math.round(future * 100)}% 最大血量`;
        },
        maxPick: Infinity,
        apply: () => {
          caterpillar.regenRate = (caterpillar.regenRate || 0) + 0.01; // +1%/次
          caterpillar.hasRegen = true;
        }
      },
      { 
        id: "energyGainUp", 
        name: "能量獲取 +20%", 
        desc: () => "吃乳草/花獲得的能量增加 20%",
        maxPick: Infinity,
        apply: () => { caterpillar.energyGainMult = (caterpillar.energyGainMult || 1) + 0.2; }
      },
      {
        id: "expGainUp",
        name: "經驗值獲取 +20%",
        desc: () => "獲得的經驗值增加 20%",
        maxPick: Infinity,
        apply: () => {
          caterpillar.expGainMult = (caterpillar.expGainMult || 0) + 0.2;
        }
      },
      { 
        id: "metamorph", 
        name: "羽化祝福", 
        desc: () => "結蛹蛻變成蝴蝶", 
        maxPick: 1,
        onlyLevel: 10,
        apply: () => {
          // 變身為蝴蝶
          caterpillar.isButterfly = true;
          caterpillarImg = butterflyImg;
          startFlowerMode();
          caterpillar.speed = Math.max(2 * caterpillar.speed, 6); // 提升速度至至少 8

          // 刪除視野距離、視野角度
          for (let i = upgrades.length - 1; i >= 0; i--) {
            if (["visionRangeUp", "visionAngleUp"].includes(upgrades[i].id)) {
              upgrades.splice(i, 1);
            }
          }

          // 加入蝴蝶專屬升級
          upgrades.push({
            id: "nectarSpeedUp",
            name: "進食時間減少 20%",
            desc: () => {
              const cur = caterpillar.nectarSpeedMult || 1;
              const future = cur * 1.2;
              return `吸食花蜜時間減少 20% (乘算)`;
            },
            maxPick: Infinity,
            apply: () => {
              caterpillar.nectarSpeedMult = (caterpillar.nectarSpeedMult || 1) * 0.8;
              feedingTime *= caterpillar.nectarSpeedMult;
            }
          });
        }
      }
    ];

    // 記錄升級項目已選次數
    const upgradePickCount = {};

    // 升級觸發
    function triggerLevelUpEvent() {
      if (caterpillar.level === 2) {
        const blessing = upgrades.find(u => u.id === "metamorph");
        if (blessing) {
          showUpgradeChoices([blessing]); // 只顯示羽化祝福
          return; // 結束函式
        }
      }

      const available = upgrades.filter(u => {
        const count = upgradePickCount[u.id] || 0;
        if (count >= u.maxPick) return false;
        if (u.onlyLevel && u.onlyLevel !== caterpillar.level) return false;
        return true;
      });

      // 隨機挑 3 個（如果不足 3 個就全給）
      const choices = [];
      while (choices.length < 3 && available.length > 0) {
        const idx = Math.floor(Math.random() * available.length);
        choices.push(available.splice(idx, 1)[0]);
      }

      showUpgradeChoices(choices);
    }

    // 套用升級效果
    function pickUpgrade(upgrade) {
      upgrade.apply();
      upgradePickCount[upgrade.id] = (upgradePickCount[upgrade.id] || 0) + 1;
    }
    
    let currentUpgradeChoices = [];
    let isGamePaused = false;

    function showUpgradeChoices(choices) {
      isGamePaused = true; // 暫停遊戲
      currentUpgradeChoices = choices;

      // 顯示卡片與動態描述
      choices.forEach((u, i) => {
        document.getElementById(`upgrade-name-${i}`).textContent = u.name;
        const descText = (typeof u.desc === 'function') ? u.desc() : u.desc;
        document.getElementById(`upgrade-desc-${i}`).textContent = descText;
        document.querySelectorAll(".upgrade-card")[i].style.display = "block";
      });

      // 如果不足3個，隱藏沒用到的卡
      for (let i = choices.length; i < 3; i++) {
        document.getElementById(`upgrade-name-${i}`).textContent = "";
        document.getElementById(`upgrade-desc-${i}`).textContent = "";
        document.querySelectorAll(".upgrade-card")[i].style.display = "none";
      }

      // 顯示容器
      document.getElementById("upgrade-container").style.display = "flex";
    }

    function pickUpgradeFromUI(index) {
      const upgrade = currentUpgradeChoices[index];
      if (upgrade) {
        pickUpgrade(upgrade);
      }

      // 關閉 UI
      document.getElementById("upgrade-container").style.display = "none";
      isGamePaused = false; // 恢復遊戲
    }
    //--------------擬態----------------------------
    function enterStealth() {
      if (!caterpillar.hasStealth) return;
      caterpillar.isStealthed = true;
    }

    function exitStealth() {
      if (!caterpillar.isStealthed) return;
      caterpillar.isStealthed = false;
      // 重設停止計時，避免立刻再進入
      caterpillar.stoppedSince = null;
    }

    // -------------------- 天敵圖片 --------------------
    const spiderImg = new Image();
    spiderImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/spider.png';

    const scorpionImg = new Image();
    scorpionImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/scorpion.png';

    const sparrowImg = new Image();
    sparrowImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/sparrow.png';

    const frogImg = new Image();
    frogImg.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/frog.png';

    // -------------------- 天敵資料表 --------------------
    const enemyTypes = [
      {
        id: "spider",
        img: (() => { let i = new Image(); i.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/spider.png'; return i; })(),
        speed: 1.5,
        scale: 0.1,
        rotateWithMovement: true,
        extraAngle: 0,
        spawnAsCaterpillar: true
      },
      {
        id: "scorpion",
        img: (() => { let i = new Image(); i.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/scorpion.png'; return i; })(),
        speed: 1.2,
        scale: 0.1,
        rotateWithMovement: true,
        extraAngle: Math.PI, // 180 度
        spawnAsCaterpillar: true
      },
      {
        id: "sparrow",
        img: (() => { let i = new Image(); i.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/sparrow.png'; return i; })(),
        speed: 2.5,
        scale: 3 * 0.1,
        rotateWithMovement: false,
        extraAngle: 0,
        spawnAsCaterpillar: true
      },
      {
        id: "frog",
        img: (() => { let i = new Image(); i.src = 'https://raw.githubusercontent.com/BonBonChou/Butterfly_Journey/main/images/frog.png'; return i; })(),
        speed: 1.8,
        scale: 3 * 0.1,
        rotateWithMovement: true,
        extraAngle: Math.PI,
        spawnAsCaterpillar: false
      }
    ];

    // -------------------- 天敵系統 --------------------
    let enemies = [];
    const enemySpawnInterval = 3000; // 每 3 秒嘗試生成
    const enemyLifetime = 10000; // 存在 10 秒
    const enemySafeRadius = 200; // 與玩家距離 < 200px 不生成

    function spawnEnemy() {
      const availableTypes = enemyTypes.filter(t => 
        caterpillar.isButterfly ? true : t.spawnAsCaterpillar
      );
      if (availableTypes.length === 0) return;

      const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];

      let spawnX, spawnY, dist;
      do {
        spawnX = caterpillar.worldX + (Math.random() - 0.5) * 1200;
        spawnY = caterpillar.worldY + (Math.random() - 0.5) * 1200;
        dist = Math.sqrt((spawnX - caterpillar.worldX) ** 2 + (spawnY - caterpillar.worldY) ** 2);
      } while (dist < enemySafeRadius);

      enemies.push({
        type: type, // 存整個 enemyType 物件
        x: spawnX,
        y: spawnY,
        speed: type.speed,
        spawnTime: Date.now(),
        dirX: Math.random() * 2 - 1,
        dirY: Math.random() * 2 - 1
      });
    }


    function updateEnemies() {
      const now = Date.now();
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        // 偶爾改變方向（每秒大約 5% 機率）
        if (Math.random() < 0.05) {
          e.dirX = Math.random() * 2 - 1;
          e.dirY = Math.random() * 2 - 1;
          const len = Math.sqrt(e.dirX * e.dirX + e.dirY * e.dirY);
          e.dirX /= len;
          e.dirY /= len;
        }

        // 移動
        e.x += e.dirX * e.speed;
        e.y += e.dirY * e.speed;

        // 時間到 -> 消失
        if (now - e.spawnTime >= enemyLifetime) {
          enemies.splice(i, 1);
          continue;
        }

        // 天敵碰撞檢查（隱形時不檢查）
        if (!caterpillar.isStealthed) {
          const dx = caterpillar.worldX - e.x;
          const dy = caterpillar.worldY - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < caterpillar.radius + 20) {
            caterpillar.health -= 30;
            if (caterpillar.health < 0) caterpillar.health = 0;
            enemies.splice(i, 1);
          }
        }
      }
    }

    function drawEnemies() {
      enemies.forEach(e => {
        const screenX = e.x - camera.x;
        const screenY = e.y - camera.y;
        const type = e.type;

        ctx.save();
        ctx.translate(screenX, screenY);

        if (type.rotateWithMovement) {
          let angle = Math.atan2(e.dirY, e.dirX) + Math.PI / 2 + type.extraAngle;
          ctx.rotate(angle);
        } else {
          ctx.rotate(type.extraAngle);
        }

        const drawW = type.img.width * type.scale;
        const drawH = type.img.height * type.scale;

        // 設定陰影來模擬外框
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 20; // 模糊值
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        ctx.drawImage(type.img, -drawW / 2, -drawH / 2, drawW, drawH);
        ctx.restore();
      });
    }

    //--------------更新畫面-----------------------------------
    function update() {
      if (isGamePaused) return; // 暫停時不更新遊戲邏輯

      if (!isUsingJoystick) {
        // 鍵盤控制時，重設速度
        caterpillar.vx = 0;
        caterpillar.vy = 0;

        if (keys["w"]) caterpillar.vy -= 1;
        if (keys["s"]) caterpillar.vy += 1;
        if (keys["a"]) caterpillar.vx -= 1;
        if (keys["d"]) caterpillar.vx += 1;

        // 用畫布的比例來修正
        const scaleY = canvas.width / canvas.height;
        let len = Math.hypot(caterpillar.vx, caterpillar.vy * scaleY);
        if (len > 0) {
          caterpillar.vx = (caterpillar.vx / len) * caterpillar.speed;
          caterpillar.vy = (caterpillar.vy / len) * caterpillar.speed;
          caterpillar.facingAngle = Math.atan2(caterpillar.vy, caterpillar.vx);
        }
      }
      // ---------- 檢查是否開始或結束隱形 ----------
      if (caterpillar.hasStealth) { // 如果玩家有擬態能力
        if (caterpillar.vx === 0 && caterpillar.vy === 0) { // 如果現在完全沒移動
          if (caterpillar.stoppedSince === null) {
            // 剛開始靜止，記錄時間
            caterpillar.stoppedSince = Date.now();
          } else {
            // 已經靜止一段時間，檢查是否達到 3000ms
            if (!caterpillar.isStealthed && (Date.now() - caterpillar.stoppedSince >= 3000)) {
              enterStealth();
            }
          }
        } else {
          // 有移動 -> 立即退出隱形（如果之前在隱形）
          if (caterpillar.isStealthed) exitStealth();
          // 也重設停止計時
          caterpillar.stoppedSince = null;
        }
      }
      if (!caterpillar.isButterfly) {
        updateMilkweeds();
      } else {
        updateFlowers();
      }
      
      updateEnemies();

      // 位置更新（無論是哪個控制方式）
      caterpillar.worldX += caterpillar.vx;
      caterpillar.worldY += caterpillar.vy;

      // 讓相機中心對準角色
      camera.x = caterpillar.worldX - game.width / 2;
      camera.y = caterpillar.worldY - game.height / 2;

      // === 檢查毛毛蟲與乳草碰撞 ===
      // **重要**：如果正在隱形則跳過碰撞（穿透）
      if (!caterpillar.isStealthed) {
        if (!caterpillar.isButterfly) {
          // === 檢查毛毛蟲與乳草碰撞 ===
          for (let i = milkweeds.length - 1; i >= 0; i--) {
            const dx = caterpillar.worldX - milkweeds[i].x;
            const dy = caterpillar.worldY - milkweeds[i].y;
            const dist = Math.hypot(dx, dy);

            if (dist < caterpillar.radius + 20) { // 20 是乳草半徑
              // 能量回復（上限 100）
              const baseGain = 10;
              const gain = Math.round(baseGain * (1 + (caterpillar.energyGainMult || 0)));
              caterpillar.energy = Math.min(100, caterpillar.energy + gain);

              // 經驗值增加（用你現有的系統）
              gainExp(10); // 每顆乳草給 10 點經驗

              // 移除乳草
              milkweeds.splice(i, 1);
            }
          }
        } else {
          // === 檢查蝴蝶與花碰撞 ===
          let isCollidingWithFlower = false;

          for (let i = 0; i < flowers.length; i++) {
            const f = flowers[i];
            const dx = caterpillar.worldX - f.x;
            const dy = caterpillar.worldY - f.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < caterpillar.radius + 20) { // 半徑 20 的花
              isCollidingWithFlower = true;

              // 如果不是同一朵花，重置進度
              if (feedingFlower !== f) {
                feedingFlower = f;
                feedingProgress = 0;
              }

              feedingProgress += deltaTime;

              // 吸食完成
              if (feedingProgress >= feedingTime) {
                // 獎勵：和乳草一樣
                caterpillar.energy = Math.min(100, caterpillar.energy + (20 * (caterpillar.energyGainMult || 1)));
                gainExp(20 * (caterpillar.expGainMult || 1));

                // 移除花
                flowers.splice(i, 1);
                feedingFlower = null;
                feedingProgress = 0;
              }
              break;
            }
          }

          if (!isCollidingWithFlower) {
            feedingFlower = null;
            feedingProgress = 0;
          }
        }
      } // end if not stealthed
    }
    

    function draw() {
      // 清除畫面
      ctx.clearRect(0, 0, game.width, game.height);
      maskCtx.clearRect(0, 0, game.width, game.height);

      drawBackground();
      if (!caterpillar.isButterfly){
        drawMilkweeds();
      } else {
        drawFlowers();
      }
      drawEnemies();
      // 先畫地圖與物件，再畫黑色遮罩
      if (!caterpillar.isButterfly) {
        drawVisionMask(); // 原本毛毛蟲的黑色遮罩
      }
      // 再畫毛毛蟲、經驗條，確保它永遠可見
      drawPlayer();
      drawPlayerBars();
      drawExpBar();
    }

    function drawBackground() {
      const pattern = ctx.createPattern(grassImg, 'repeat');
      ctx.save();
      ctx.globalAlpha = 0.8; // 透明度（0=完全透明，1=不透明）
      ctx.translate(-camera.x % grassImg.width, -camera.y % grassImg.height);
      ctx.fillStyle = pattern;
      ctx.fillRect(-grassImg.width, -grassImg.height, game.width + grassImg.width * 2, game.height + grassImg.height * 2);
      ctx.restore();
    }

    function gameOver() {
      game.running = false;
      location.href="https://bonbonchou.github.io/Butterfly_Journey/fail_ending.html";
    }

    let lastTime = 0; // 前一幀的時間
    let deltaTime = 0; // 這一幀與上一幀的時間差（單位：秒）
    function gameLoop(timestamp) {
      if (!game.running) return;

      // 將 timestamp（毫秒）轉為秒差
      deltaTime = (timestamp - lastTime);
      lastTime = timestamp;


      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // =================================== 虛擬搖桿控制 ==================================================================
    const joystickContainer = document.getElementById("joystick-container");
    const joystick = document.getElementById("joystick");
    let dragging = false;
    let joyStart = { x: 0, y: 0 };

    // 顯示搖桿並設定初始位置
    function showJoystick(x, y) {
      joystickContainer.style.display = "flex";
      joystickContainer.style.left = `${x - 50}px`; // 中心對齊
      joystickContainer.style.top = `${y - 50}px`;
    }

    // 隱藏搖桿
    function hideJoystick() {
      joystickContainer.style.display = "none";
      caterpillar.vx = 0;
      caterpillar.vy = 0;
    }

    // 將螢幕座標轉換為 Canvas 內部座標
    function getCanvasCoordinates(touchEvent) {
        const rect = canvas.getBoundingClientRect(); // 獲取畫布在螢幕上的實際位置和大小
        const touch = touchEvent.touches[0];

        // 計算縮放比例
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // 進行座標轉換
        const canvasX = (touch.clientX - rect.left) * scaleX;
        const canvasY = (touch.clientY - rect.top) * scaleY;

        return { x: canvasX, y: canvasY };
    }

    window.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      // 視覺上的搖桿依然使用螢幕座標，才能正確顯示在手指下方
      showJoystick(touch.clientX, touch.clientY); 
      
      // 但我們的遊戲邏輯，使用轉換後的畫布座標
      const coords = getCanvasCoordinates(e);
      joyStart = { x: coords.x, y: coords.y };
      dragging = true;
      isUsingJoystick = true; // 代表當前由搖桿控制
    });

    window.addEventListener("touchmove", (e) => {
      if (!dragging) return;
      // 同樣，將當前手指位置也轉換為畫布座標
      const coords = getCanvasCoordinates(e);

      // dx 和 dy 現在是基於 800x600 畫布的正確向量
      const dx = coords.x - joyStart.x;
      const dy = coords.y - joyStart.y;

      const len = Math.hypot(dx, dy); // 因為座標已經被校正，不再需要手動乘以 scaleY
      if (len > 0) {
        // 直接用 dx 和 dy 來計算速度，len 會負責將其標準化
        caterpillar.vx = 1.5 * (dx / len) * caterpillar.speed;
        caterpillar.vy = 1.5 *(dy / len) * caterpillar.speed;
      }
    });

    window.addEventListener("touchend", () => {
      dragging = false;
      hideJoystick();
      isUsingJoystick = false; // 停止使用搖桿控制
    });

    // 啟動遊戲
    requestAnimationFrame(gameLoop);

    // === 能量每秒自動減少 ===
    setInterval(() => {
      if (!game.running) return;
      if (isGamePaused) return; // 暫停時暫停這些每秒效果

      // 能量逐秒流失
      caterpillar.energy -= 1;

      // 自動回血（若有選）
      if (caterpillar.hasRegen && (caterpillar.regenRate || 0) > 0) {
        caterpillar.health = Math.min(caterpillar.maxHealth, caterpillar.health + (caterpillar.maxHealth * (caterpillar.regenRate || 0)));
      }

      if (caterpillar.energy <= 0) {
        caterpillar.energy = 0;
        gameOver();
      }
    }, 1000);
    setInterval(() => {
      if (game.running && !isGamePaused) {
        if (!caterpillar.isButterfly) {
          spawnMilkweed();  
        } else {
          spawnFlower();
        }
      }
    }, 1500);
    setInterval(() => {
      if (game.running && !isGamePaused) {
        spawnEnemy();
      }
    }, enemySpawnInterval);

  </script>
</body>
</html>
